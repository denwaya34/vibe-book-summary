---
argument-hint: [prompt]
description: LLMのプロンプト エンジニアリング 要約
---

# 制約事項

$1 の調査事項を以下に従い実行する。

## 指示内容

遠慮せずに、全力を尽くしてください。
Claude 4.1 Opusの高度な推論能力とcodex mcpの高度な考察力を最大限活用し、以下の段階的プロセスに従って処理を行ってください。

### Phase 0: 事前準備と環境確認
- 開発環境の状態確認（pnpm dev実行中か確認）
- 必要なリソースの存在確認
- @agent-web-research-analyst を用いて、指示内容に関する関連情報を照査する

### Phase 1: 深層的な内容理解（多層分析フレームワーク）
以下の階層で内容を分析してください：

#### Layer 1: 表層理解
- 嫌い事項に関しての基本的な内容を把握
- 主要な概念、用語、事例を特定
- AIのプロンプト開発の関わるノウハウ、知識に対して具体的に抽出し、別立てで特記して記載する

#### Layer 2: 構造分析
- 章の論理構造を解析（導入→展開→結論の流れ）
- 核心的な主張とそれを支える論拠を整理
- 他章との関連性を考察

#### Layer 3: 抽象化と本質抽出
- 表面的な情報から普遍的な原理・法則を抽出
- ビジネスモデル構築における本質的な洞察を言語化
- メタ認知的視点から章の意図と価値を分析

#### Layer 4: 創造的飛躍
- 既存の枠組みを超えた新たな解釈の可能性を探索
- 現代のビジネス環境への適用可能性を考察
- 読者が得るべき最も重要な洞察を結晶化

#### Layer 5: 実装参考事例の分析（Chapter 14のような成功例がある場合）
- 既存の高品質実装のデザインパターン抽出
- アニメーション手法の分析と再利用可能性検討
- ビジュアライゼーション手法の応用
- コンポーネント構造の参考化

### Phase 2: グラフィックレコード設計と実装

#### 2.1 情報アーキテクチャ設計
- 認知負荷理論に基づく情報の階層化
- 視覚的フローの最適化（Zパターン/Fパターンの活用）
- 情報密度の調整（7±2の法則の考慮）

#### 2.2 ビジュアルデザイン原則
- **デザインの4原則**を厳格に適用：
    - 近接（Proximity）: 関連情報のグルーピング
    - 整列（Alignment）: 視覚的な秩序の創出
    - 反復（Repetition）: 統一感のあるデザイン要素
    - コントラスト（Contrast）: 情報の優先順位の明確化

#### 2.3 実装仕様
- 実装ファイルパス @src/index.html
- 技術スタック: React 19, TypeScript, Tailwind CSS v4, DaisyUI, Motion
- レスポンシブ対応（モバイルファースト）
- アクセシビリティ考慮（WCAG 2.1 AA準拠）

#### 2.4 ビジュアル要素
- **色彩設計**:
    - プライマリ/セカンダリ/アクセントカラーの戦略的使用
    - 色彩心理学に基づく感情誘導
    - DaisyUIのテーマシステムを活用
    - グラデーション背景（bg-gradient-to-br）による深みの演出
- **タイポグラフィ**:
    - 読みやすさを最優先（Geistフォント活用）
    - 情報階層に応じたフォントサイズ・ウェイト
    - グラデーションテキスト（bg-clip-text）でのビジュアルインパクト
- **グラフィック要素**:
    - SVGアイコンやイラストレーションの活用
    - Rechartsでのデータビジュアライゼーション
    - Motionライブラリでの洗練されたアニメーション
- **コンポーネントデザイン**
    - コンポーネントデザインは以下のatlassianデザインシステムを参考にする
      https://atlassian.design/components

#### 2.5 高度なアニメーション実装
- **motion/react活用**:
    - useScroll, useTransform, useSpring, useInViewフックの組み合わせ
    - スクロール連動の背景アニメーション（backgroundY変換）
    - 回転アニメーション（rotateValue）による動的演出
- **MotionSectionコンポーネント**:
    - 方向指定アニメーション（left, right, up, down）
    - 遅延設定による段階的表示
    - IntersectionObserverによる視認性判定
- **インタラクティブ要素**:
    - ホバー時のスケール変化（whileHover）
    - アクティブ状態の管理（useState）
    - SVGパスアニメーション（pathLength）

#### 2.6 データビジュアライゼーション実装
- **Rechartsの高度な活用**:
    - 複数軸グラフ（LineChart with dual Y-axis）
    - レーダーチャート（RadarChart）による多次元データ表現
    - カスタムツールチップコンポーネント
    - グラデーション塗りつぶし（linearGradient）
- **レスポンシブコンテナ**:
    - ResponsiveContainerによる自動サイズ調整
    - モバイル対応のレイアウト切り替え

#### 2.7 視覚的洗練度の向上
- **エフェクトの階層的使用**:
    - backdrop-blur効果（backdrop-blur-sm, backdrop-blur-xl）
    - 多層的なshadow（shadow-lg, shadow-xl, shadow-2xl）
    - 透明度調整（bg-white/70, bg-white/90）
- **フィードバックループの可視化**:
    - 動的な矢印アニメーション
    - 条件付きレンダリング（モバイル/デスクトップ）
    - 継続的なループ表現（rotate animation）
- **カード型レイアウト**:
    - DaisyUIのcardコンポーネント活用
    - グリッドシステムでの配置最適化
    - hover効果での視覚的フィードバック

#### 2.8 実装成功のチェックリスト
- [ ] 動的背景が実装されているか（スクロール連動）
- [ ] MotionSectionコンポーネントが適切に使用されているか
- [ ] データビジュアライゼーションが含まれているか
- [ ] インタラクティブな要素があるか（ホバー効果など）
- [ ] レスポンシブデザインが完璧か
- [ ] パフォーマンスが最適化されているか
- [ ] アクセシビリティが考慮されているか

### Phase 3: 品質保証プロセス（Playwright MCP活用）

#### 3.1 初期動作確認
```
- 開発サーバーを実行する。
- ページの正常なレンダリング確認
- コンソールエラーの不在確認
```

#### 3.2 詳細検証項目
- **レイアウト検証**:
    - 各要素の配置精度
    - レスポンシブブレークポイントでの表示
    - スクロール動作の滑らかさ
- **コンテンツ検証**:
    - テキストの可読性
    - 画像/グラフィックの表示品質
    - インタラクティブ要素の動作
- **パフォーマンス検証**:
    - 初期ローディング時間
    - インタラクションの応答性

#### 3.3 問題検出時の対応
- 具体的な問題箇所の特定
- 根本原因の分析
- 修正案の実装
- Phase 2への戻り（必要に応じて）

### Phase 4: 段階的品質向上プロセス

#### 4.1 現状分析（客観的評価基準）
- **情報設計**: 構造の明確性、フローの自然さ
- **視覚デザイン**: 美的完成度、ブランド一貫性
- **ユーザビリティ**: 直感性、アクセシビリティ
- **技術実装**: コード品質、パフォーマンス

#### 4.2 改善計画策定
- 各評価軸での具体的な改善点リスト化
- 優先順位付け（影響度×実現可能性マトリクス）
- 段階的実装計画

#### 4.3 改善実装
- 1つずつ着実に改善を実装
- 各改善後の効果測定
- 累積的な品質向上の確認

### Phase 5: 最終品質検証

#### 5.1 総合的デザインレビュー
- Playwright MCPでの全画面キャプチャ
- デザイン一貫性の確認
- 意図しないレイアウト崩れの検出

#### 5.2 クロスブラウザ/デバイス確認
- 主要ブラウザでの表示確認
- 各種デバイスサイズでの検証

#### 5.3 アクセシビリティ監査
- キーボードナビゲーション
- スクリーンリーダー対応
- カラーコントラスト比

### Phase 6: ビルドと最終確認

#### 6.1 プロダクションビルド
```bash
npm run build
```

#### 6.2 エラー対応
- TypeScriptエラーの解決
- ESLintエラーの修正
- ビルド最適化の確認

#### 6.3 成功確認
- ビルド成功メッセージの確認
- 生成されたファイルサイズの確認
- パフォーマンス指標の確認

## エラーハンドリング

### 各フェーズでの失敗時対応
- 具体的なエラーメッセージと原因の記録
- リカバリー手順の実行
- 必要に応じて前フェーズへの巻き戻し

### 最終的な品質保証
- 全フェーズの完了確認
- ドキュメント化（実装の決定事項）
- 今後の改善提案の記録
